% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expressions.R
\name{split_expression}
\alias{split_expression}
\alias{expr2terms}
\alias{expr2terms_string}
\alias{fun2terms}
\alias{fun2terms_drop_assignments}
\alias{fun2funcalls}
\title{Split expressions into terms}
\usage{
split_expression(..., is_lang = FALSE, only_names = FALSE)

expr2terms(x, only_names = FALSE)

expr2terms_string(x, only_names = FALSE)

fun2terms(fun)

fun2terms_drop_assignments(fun)

fun2funcalls(fun)
}
\description{
\code{split_expression()} takes one or more expressions (optionally as
strings, unless \code{is_lang=TRUE}) and splits them up into
individual language elements (via \code{expr2terms_string()} or
\code{expr2terms()}). With \code{only_names=TRUE}, only elements that
correspond to standard object names (i.e., those starting with a
letter or dot) are returned.
}
\details{
\code{expr2terms()} splits up a single expression. \code{expr2terms_string()}
takes string input and converts it to language first before calling
\code{expr2terms()}.

\code{fun2terms()} splits up an entire function into constituent parts (all).

\code{fun2funcalls()} splits up an entire function into constituent parts
and returns those parts that correspond to function calls.
}
\examples{
split_expression(c("I(A/B/1000/(D*G))", 'I(Wealth - Health)*Age'))
unlist(lapply(as.list(body(optimize)), FUN=split_expression, assume_lang=TRUE))

# get all expressions in base::sample (including arguments)
fun2terms(base::sample)    # a list of length 47

# extract calls to functions from a function
print(fun2funcalls(mean.default))

}
