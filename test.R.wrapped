#' @title
#' Harmonic mean
#'
#' @description
#' Calculates the harmonic mean (single value) of a single vector
#' created as a combination of all its input arguments.
#' @export
hmean = function(...) {
  if(length(c(...))) 1/mean(1/c(...)) else c(...)
}

#' @title
#' Geometric mean
#' @description
#' @export
gmean = function(x, na.rm=FALSE) {
  if(na.rm) x = x[!is.na(x)]
  #prod(x)^(1/length(x))
  exp(sum(log(x)/length(x)))
}

#' @title
#' (Weighted) geometric mean
#' @description
#' @export
gmean = function(x, w, ...)
  exp(weighted.mean(log(x), w, ...))

#' @title
#' (Weighted) logistic mean
#' @description
#' @export
pmean <- function(x, w, ...)
  plogis(weighted.mean(qlogis(x), w, ...))

#' @title
#' Arithmetic mean
#'
#' @description
#' Arithmetic mean of `x`. Same functionality as [base::mean] except
#' with different output when input has zero length. @export
amean = function(x, na.rm=FALSE) {
  if(na.rm) x = x[!is.na(x)]
  if(length(x)) mean(x) else NULL
}

#' @title
#' Arithmetric mean
#'
#' @description
#' A version of [base::mean] which removes `NA` values by default.
#' @export
#' @examples
#' x = c(1,NA); mean(x); mean2(x)
mean2 = function(..., na.rm=TRUE) {
  base::mean(..., na.rm=na.rm)
}

#' @title
#' Mode of a sample
#'
#' @description
#' Finds the mode, i.e. the value that occurs with highest frequency
#' in `x`. The function works for both numeric and character/factor
#' data. @export
Mode = function(x, all_modes=FALSE, exclude.na=TRUE) {
  ux = unique(x)
  if(exclude.na) ux = ux[!is.na(ux)]
  tab = tabulate(match(x, ux))
  if(all_modes) {
    ux[tab == max(tab)]
  } else {
    ux[which.max(tab)]
  }
}

#' @title
#' Get autocorrelation
#'
#' @description
#' Calculates autocorrelation of x with given lag @export
acor = function(x, lag=1) {
  suppressWarnings(cor(x[-((length(x)-lag+1):length(x))], x[-(1:(lag))]))
}

#' @title
#' Logit, probit, inverse logit functions
#' @description
#' @export
logit = function(p)
  stats::qlogis(p)
  #log(p/(1-p))

#' @title
#' @export
probit = function(p)
  stats::qnorm(p)
#probit = stats::qnorm

#' @title
#' @export
ilogit = function(x)
  stats::plogis(x)
#ilogit = function(x) 1 / (1+exp(-x))
#invlogit = function(x) exp(x)/(1+exp(x))
#invlogit = function(x) exp(x)/(1+exp(-x))

#' @title
#' Quantile function of a weighted chi-square distribution
#'
#' @description
#' Returns the quantile of a distribution that arises when
#' independent chisquare-distributed variables with `df0` degrees of
#' freedom are summed on the logarithmic scale with weights in `w`
#' @export
qchisqw = function(p, weights, lower.tail=TRUE, epsw=1e-5, epsv=1e-12, df0=2) {

  if(any(weights<0)) error("Negative weights!")

  # Check the input
  np = length(p)
  if(np==1) {
    weights = matrix(weights, nrow=1)
  } else if(is.vector(weights)) {
    weights = matrix(rep(weights, e=np), nrow=np)
  }
  stopifnot(is.matrix(weights), nrow(weights)==np)

  # Get the chisquare quantile
  q0 = qchisq(p, df=df0*ncol(weights), lower.tail=FALSE) * apply(t(weights), 2, mean)

  # If weights are different, use pchisqw
  if(diff(range(weights)) < epsw) {
    q0
  } else {
    logp = log(p)
    fun = function(x) (log(pchisqw(x, weights=weights, lower.tail=lower.tail, epsw=epsw, df0=df0)) - logp)^2
    value = 1
    iter = 0
    max_iter = 10
    while(value>epsv && iter<max_iter) {
      iter = iter + 1
      x = optim(q0, fun, method="Brent", lower=0, upper=5*q0)
    }
    if(x$value>epsv) error("Non-convergent optimization in qchisqw() (value ",x$value,")!")
    x$par
  }

}

#' @title
#' Get the probability of a weighted chi-square sum
#'
#' @description
#' Calculates the probability of a weighted sum of chisquare-df0
#' variables being below (lower.tail==TRUE) or above
#' (lower.tail=FALSE) x, where weights specifies the weights. Fails
#' if some (but not all) weights are equal @export
pchisqw = function(x, weights, lower.tail=TRUE, epsw=1e-5, df0=2) {

  nx = length(x)
  if(nx==1) {
    weights = matrix(weights, nrow=1)
  } else if(is.vector(weights)) {
    weights = matrix(rep(weights, e=nx), nrow=nx)
  }
  stopifnot(is.matrix(weights), nrow(weights)==nx)

  # If all equal, use standard chisquare distribution function
  if(diff(range(weights))<epsw) {

    p = pchisq(x, df=df0 * ncol(weights), lower.tail=lower.tail)

  # Otherwise use Box (1953), Theorem 2.4
  } else {

    # Calculate the probability of exceeding x
    wx = x / weights
    px = pchisq(wx, df=df0, lower.tail=FALSE)
    a = sapply(1:nx, function(i)
          sapply(1:ncol(weights), function(j) prod(weights[i,j]/(weights[i,j]-weights[i,-j]))))
    p = apply(a * t(px), 2, sum)

    # Get the lower tail probability (i.e. probability of not exceeding x)
    if(lower.tail) p = 1. - p

  }

  return(p)

}

#' @title
#' Normal tail probability
#'
#' @description
#' Returns an upper tail probability of the normal distribution
#' @export
upnorm = function(..., lower.tail=FALSE) stats::pnorm(..., lower.tail=lower.tail)

#' @title
#' Normal tail probability
#'
#' @description
#' Returns an upper tail quantile of the normal distribution @export
uqnorm = function(..., lower.tail=FALSE) stats::qnorm(..., lower.tail=lower.tail)

#' @title
#' Normal probability of a rectangle
#'
#' @description
#' Calculates the probability of an arbitrary box with respect to an
#' equi-correlated multivariate normal random vector of dimension
#' given by the size of upper/lower @export
pmnormrect = function(upper=c(Inf, Inf), lower=c(-Inf,-Inf), mean=rep(0, length(upper)),
                      Sigma=diag(length(upper)), varcov) {

  if(!missing(varcov) && !missing(Sigma)) error("Supply either Sigma or varcov.")
  if(!missing(varcov)) Sigma = varcov

  llibrary(mnormt)

  P = if(all(is.infinite(lower)))
    mnormt::pmnorm(upper, mean=mean, varcov=Sigma) else
    mnormt::sadmvn(lower=lower, upper=upper, mean=mean, varcov=Sigma)

  return(as.numeric(P))
}

#' @title
#' Normal distribution p-value
#'
#' @description
#' Calculates the p-value relative to the normal distribution with
#' parameters `m` (mean) and `s` (standard deviation).
#'
#' @examples
#' normpval(1.96)        # approx. 2.5%
#' normpval(1.96, TRUE)  # approx. 5.0%
#' @export
normpval = function(x, two.sided=FALSE, m=0, s=1) {
  pnorm(abs(x), lower.tail=ifelse(two.sided, FALSE, x<0)) * (1+two.sided)
  #if(two.sided) 2*pnorm(abs(x), m=m, s=s, lower.tail=FALSE) else pnorm(x, m=m, s=s, lower.tail=FALSE)
}

#' @title
#' Samples n variables from an arbitrary density function specified
#' in 'pdf'
#' @description
#' @export
samplepdf = function(n, pdf, ..., spdf.lower = -Inf, spdf.upper = Inf) {

  endsign = function(f, sign = 1) {
      b = sign
      while (sign * f(b) < 0) b = 10 * b
      return(b)
  }

  vpdf = function(v) sapply(v, pdf, ...)  # vectorize
  cdf = function(x) integrate(vpdf, spdf.lower, x)$value
  invcdf = function(u) {
      subcdf = function(t) cdf(t) - u
      if (spdf.lower == -Inf)
          spdf.lower = endsign(subcdf, -1)
      if (spdf.upper == Inf)
          spdf.upper = endsign(subcdf)
      return(uniroot(subcdf, c(spdf.lower, spdf.upper))$root)
  }

  sapply(runif(n), invcdf)

}

#' @title
#' Empirical probability frequency (density)
#'
#' @description
#' @export
#' @examples
#' ecf(sample(1:3, 100, repl=TRUE))
edf = function(x) {
  y = c(table(x))
  y / sum(y)
}

#' @title
#' P-value combination
#'
#' @description
#' Combines p-values using one of the available methods @export
combine_pvalues = function(P, lam, method=c("jelle","jakub","fisher","stouffer"), summarize=FALSE, ...) {

  if(is.vector(P)) P = matrix(P, nrow=1, ncol=length(P))

  if(summarize) {
    cat0("Smallest raw p-value: ",min(P),"\n")
    w = which.min(apply(log10(P), 1, mean))
    cat0("Row with the smallest average p-values (on log scale): ",w,"\n")
    print(P[w,])
    c1 = do_pval_comb(P[w,], method="fisher")
    cat0("Fisher combination of these p-values: ",c1,"\n")
    c2 = do_pval_comb(P[w,], method="jelle")
    cat0("Jelle combination of these p-values: ",c2,"\n")
  }

  do_pval_comb(P, lam, method, ...)

}

#' @title
#' P-value combination using Fisher method
#'
#' @description
#' Combines p-values using the Fisher combination methods @export
combine_fisher = function(p, silent=TRUE)
  do_pval_comb(p, method="fisher", trace=1*!silent)

#' @title
#' P-value combination using Fisher method
#'
#' @description
#' Combines p-values using the Stouffer's combination methods @export
combine_stouffer = function(p, silent=TRUE)
  do_pval_comb(p, method="stouffer", trace=1*!silent)

#=======================================================================#
# Code by Jelle Goeman. Calculates the asymptotic p-value using methods #
# of Kotz, Johnson and Boyd (1967) and Box (1954)                       #
#=======================================================================#

.pAsymptotic = function(x, lams, bet, accuracy=1e-12) {

  m = length(lams)

  if (lams[1] == 0) {
    upper = 1.0
  } else {
    if (m == 1) {
      upper = pchisq(x / lams, df = 1, lower.tail = FALSE)
    } else {
      # get the tuning parameter beta
      if (missing(bet)) {
        lams = sort(lams)
        ruben = 2 * lams[1] * lams[m] / (lams[1] + lams[m])
        harmonic = 1/mean(1/lams)
        bet = min(ruben, harmonic) * (1. - 1e-15)
      }
      # get an upper bound to the number of iterations needed
      A = qnorm(.Machine$double.neg.eps)^2
      B = x/bet
      maxiter = trunc(0.5 * (A + B + sqrt(A*A + 2*A*B) - m))
      # starting values
      #maxiter = sum(maxiter)
      d = numeric(maxiter)
      c = numeric(maxiter+1)
      c[1] = prod(sqrt(bet / lams))
      sumc = c[1]
      chi = pchisq(x / bet, df = m, lower.tail = FALSE)
      partialsum = c[1] * chi
      dbase = (1 - bet /lams)
      ready = FALSE
      mixture = TRUE
      ix = 1
      # iterate!
      while (!ready) {
        d[ix] = 0.5 * sum(dbase^ix)
        c[ix+1] = mean(c[1:ix] * d[ix:1])
        if (c[ix+1] < 0)
          mixture = FALSE
        sumc = sumc + c[ix+1]
        partialsum = partialsum + c[ix+1] * chi
        chi = pchisq(x / bet, df = m + 2 * ix + 2, lower.tail = FALSE)
        lower = partialsum + (1.0 - sumc) * chi
        upper = partialsum + 1.0 - sumc
        if (mixture)
          ready = ((upper - lower) / (upper + lower) < 10^-5) ||
                   (ix == maxiter) || (upper < accuracy)
        else {
          ready = TRUE
          upper = .pAsymptotic(x, lams, mean(c(bet, min(lams))))
        }
        ix = ix + 1
      }
    }
  }

  if (upper < accuracy) upper = accuracy / 10.0

  return(upper)
}

#' @title
#' Combine p-values
#'
#' @description
#' Performs combination of p-values using Fisher method or Box
#' method (the latter via Jelle's code in .pAsymptotic or Jakub's
#' code below @export
do_pval_comb = function(P, lam=1, method="jelle", eps_p=1e-3, fac_lam=1e-2,
  Debug=FALSE, na.rm=TRUE, trace=1) {

  # Check for unknown combination method
  if(all(method!=c("fisher","stouffer","jakub","jelle")))
    error("Unknown combination method '",method,"'!")

  # Replace non-sensical p-values with NA
  if(trace>0) cat0("Checking for NA values ...\n")
  P[P<0. | P>1.] = NA

  # Make sure P is a matrix
  if(is.vector(P)) P = matrix(P, nrow=1, ncol=length(P))

  # Store dimensions of P
  nres = ncol(P)
  np = nrow(P)

  # Make sure no weighing is done when lam=1
  if(length(lam)==1 && lam==1) lam = rep(lam, ncol(P))

  if(is.vector(lam)) {
    same_lam = TRUE
    mat_lam = matrix(lam, nrow=np, ncol=nres, byrow=TRUE)
  } else {
    same_lam = FALSE
    mat_lam = lam
  }

  # Check problems with P and lambda
  if(any(dim(mat_lam)!=dim(P)))
    stop("Incompatible sizes of lam and P!")
  if(all(lam==0)) stop("Some values in lam must be non-zero!")

  # Transform p-values to chisquare-2 variables
  if(trace>0) cat("Getting the logarithm of the p-values ...\n")
  if(any(method==c("fisher","jakub","jelle"))) chi2 = -2*log(P)

  # Combine using Fisher's method
  if(tolower(method)=="fisher") {

    if(trace>0) cat("Combining p-values (",nrow(chi2)," sets) via Fisher's method (no weighing) ...\n", sep="")
    X0 = apply(chi2, 1, sum, na.rm=na.rm)
    nres = apply(!is.na(chi2), 1, sum)
    PP = pchisq(X0, df=2*nres, lower.tail=FALSE)

  } else if(tolower(method)=="stouffer") {

    if(trace>0) cat("Combining p-values (",nrow(chi2)," sets) via Stouffer's z-score method (with weighing) ...\n", sep="")
    Z = qnorm(P, lower.tail=FALSE)
    X0 = apply(mat_lam*Z, 1, sum, na.rm=na.rm) / sqrt(apply(mat_lam^2, 1, sum))
    PP = pnorm(X0, lower.tail=FALSE)

  # Combine using Box's method
  } else {

    if(missing(lam)) stop("Missing lam in do_pval_comb()!")

    # Define lam as matrix and calculate the score
    X0 = apply(mat_lam*chi2, 1, sum, na.rm=na.rm)

    if(trace>0)
      cat0("Combining p-values (",nrow(chi2)," sets) via Box's method (with weighing, ",method,"'s code) ...\n")

    # Use Jelle's general implementation (slow)
    if(tolower(method)=="jelle") {

      PP = sapply(1:np, function(i) .pAsymptotic(X0[i], lams=rep(mat_lam[i,], t=2), accuracy=1e-100))

    # Use Jakub's less general implementation (fast)
    } else {

      # If weights are too close, randomize them
      mindif = 0 #.005*diff(range(lam))
      mdif = apply(mat_lam, 1, min_dif)
      #print(summary(mdif))
      if(any(mdif <= mindif)) {
        if(trace>0) cat0("Randomizing weights ...\n")
        if(same_lam) {
          rlam = randomize(lam, mindif=mindif)
          mat_lam = matrix(lam, nrow=np, ncol=nres, byrow=TRUE)
        } else {
          for(i in 1:np) {
            if(mdif[i]>mindif) next
            if((i==1 || i%%100==0) && trace>0) cat("Randomizing p-value ",i," out of ",np," ...\n",sep="")
            if(Debug) {
              print("--------------------------")
              print(min_dif(mat_lam[i,]))
            }
            mat_lam[i,] = randomize(mat_lam[i,], mindif=mindif)
            if(Debug)
              print(min_dif(mat_lam[i,]))
          }
          #mat_lam = apply(mat_lam, 1, randomize, mindif=mindif)
        }
      }

      # Check for zeros (which there really should not be at this point)
      mdif = apply(mat_lam, 1, min_dif)
      if(any(mdif==0))
        error("Some weights are equal, which is not allowed with Jakub's code.", Q=!interactive())

      Q = X0 / mat_lam
      PQ = pchisq(Q, df=2, lower.tail=FALSE)

      a = if(same_lam) {
        sapply(1:nres, function(j) prod(lam[j]/(lam[j]-lam[-j])))
      } else {
        sapply(1:np, function(i) sapply(1:nres, function(j) prod(mat_lam[i,j]/(mat_lam[i,j]-mat_lam[i,-j]))))
      }

      PP = apply(a * t(PQ), 2, sum)

      if(Debug) {
        print("summary(lam)"); print(summary(as.vector(lam)))
        print("summary(a)"); print(summary(as.vector(a)))
        print("summary(Q)"); print(summary(as.vector(Q)))
        print("summary(PP)"); print(summary(as.vector(PP)))
        print("min(PQ)"); print(min(PQ, na.rm=TRUE))
        print("min(PP)"); print(min(PP, na.rm=TRUE))
      }

    } # if(method=="jakub")

    if(any(is.na(PP) & !is.na(X0)))
      error("Non-NA input p-values were combined into NA p-values!", Q=!interactive())
    if(any(!is.na(PP)) && min(PP, na.rm=TRUE)<0)
      error("Some p-values are negative!", Q=!interactive())

  }

  # If any p-values are negative, correct them using Jelle's code
  if(any(PP<0.0, na.rm=TRUE)) {
    wn = which(PP<0.0)
    if(!exists(".pAsymptotic", mode="function"))
      error("Missing function .pAsymptotic()! Look for Jelle's script that",
            " defines the function.")
    PP[wn] = sapply(seq_along(wn), function(i)
               .pAsymptotic(X0[wn[i]], lams=rep(mat_lam[i,], t=2), accuracy=1e-100))
  }

  # Check for PP above 1 and trim them if they are very close
  if(any(PP>1.0, na.rm=TRUE))
    PP[PP>1.0 & PP<1+eps_p] = 1.0

  # Check again for PP above 1 even after correction
  if(any(PP>1.0, na.rm=TRUE)) {
    cat("\nERROR: SOME P-VALUES ABOVE 1!\n\n")
    cat("Maximum p-value: ", max(PP), "\n", sep="")
    print(summary(PP))
    if(interactive()) browser() else stop()
  }

  # Announce the smallest combined p-value
  if(trace>0) cat0("Smallest combined p-value: ",min(PP, na.rm=TRUE),"\n")

  # Compare the output of Jakub's and Jelle's codes for small p-values
  eps = 1e-6
  if(FALSE && any(PP<eps, na.rm=TRUE)) {
    cat0("Checking results for small p-values (",sum(PP<eps)," p-values below ",eps,") ...\n")
    ws = which(PP<eps)
    PP2 = sapply(X0[ws], .pAsymptotic, lams=rep(lam, t=2), accuracy=1e-100)
    cat0("Smallest p-value found after re-check: ",min(PP2),"\n")
    md = max(abs(PP[ws]-PP2))
    cat0("Maximum difference between Jakub's and Jelle's code: ",md,"\n")
    mrd = max(abs((PP[ws]-PP2)/unzero(PP[ws]+PP2)*2-1))
    cat0("Maximum relative difference between Jakub's and Jelle's code: ",mrd,"\n")
    PP[ws] = PP2
  }

  # If there are still negative or NA p-values, stop
  if(any(PP<0.0, na.rm=TRUE))
    error("Some p-values are negative!", Q=!interactive())
  if(any(is.na(PP) & !is.na(X0)))
    error("Non-NA input p-values were combined into NA p-values!", Q=!interactive())

  return(PP)

}

#' @title
#' Bootstrap
#'
#' @description
#' Returns a vector of B bootstrap values of real-valued statistic
#' T, where T should be an R-function which returns a scalar.
#' Arguments of T can be supplied via the ellipsis '...'. If length
#' of x and B are small enough, do it all at once Otherwise, do it
#' for each iteration separately. @export
bootstrap = function(x, T, B = 100., ..., portion=1e8) {
  if(length(x)*B < portion) {
    X = matrix(sample(x, length(x)*B, replace = TRUE), nrow=length(x))
    apply(X, 2, T, ...)
  } else {
    sapply(1:B, function(i) T(sample(x, replace = TRUE), ...))
  }

}

x = 44-43
